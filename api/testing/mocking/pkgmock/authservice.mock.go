// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package pkgmock

import (
	"mysite/pkgs/auth"
	"sync"
)

// Ensure, that AuthServiceMock does implement auth.AuthService.
// If this is not the case, regenerate this file with moq.
var _ auth.AuthService = &AuthServiceMock{}

// AuthServiceMock is a mock implementation of auth.AuthService.
//
//	func TestSomethingThatUsesAuthService(t *testing.T) {
//
//		// make and configure a mocked auth.AuthService
//		mockedAuthService := &AuthServiceMock{
//			ComparePasswordAndHashFunc: func(password string, encodedHash string) (bool, error) {
//				panic("mock out the ComparePasswordAndHash method")
//			},
//			HashPasswordFunc: func(password string) (string, error) {
//				panic("mock out the HashPassword method")
//			},
//		}
//
//		// use mockedAuthService in code that requires auth.AuthService
//		// and then make assertions.
//
//	}
type AuthServiceMock struct {
	// ComparePasswordAndHashFunc mocks the ComparePasswordAndHash method.
	ComparePasswordAndHashFunc func(password string, encodedHash string) (bool, error)

	// HashPasswordFunc mocks the HashPassword method.
	HashPasswordFunc func(password string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// ComparePasswordAndHash holds details about calls to the ComparePasswordAndHash method.
		ComparePasswordAndHash []struct {
			// Password is the password argument value.
			Password string
			// EncodedHash is the encodedHash argument value.
			EncodedHash string
		}
		// HashPassword holds details about calls to the HashPassword method.
		HashPassword []struct {
			// Password is the password argument value.
			Password string
		}
	}
	lockComparePasswordAndHash sync.RWMutex
	lockHashPassword           sync.RWMutex
}

// ComparePasswordAndHash calls ComparePasswordAndHashFunc.
func (mock *AuthServiceMock) ComparePasswordAndHash(password string, encodedHash string) (bool, error) {
	if mock.ComparePasswordAndHashFunc == nil {
		panic("AuthServiceMock.ComparePasswordAndHashFunc: method is nil but AuthService.ComparePasswordAndHash was just called")
	}
	callInfo := struct {
		Password    string
		EncodedHash string
	}{
		Password:    password,
		EncodedHash: encodedHash,
	}
	mock.lockComparePasswordAndHash.Lock()
	mock.calls.ComparePasswordAndHash = append(mock.calls.ComparePasswordAndHash, callInfo)
	mock.lockComparePasswordAndHash.Unlock()
	return mock.ComparePasswordAndHashFunc(password, encodedHash)
}

// ComparePasswordAndHashCalls gets all the calls that were made to ComparePasswordAndHash.
// Check the length with:
//
//	len(mockedAuthService.ComparePasswordAndHashCalls())
func (mock *AuthServiceMock) ComparePasswordAndHashCalls() []struct {
	Password    string
	EncodedHash string
} {
	var calls []struct {
		Password    string
		EncodedHash string
	}
	mock.lockComparePasswordAndHash.RLock()
	calls = mock.calls.ComparePasswordAndHash
	mock.lockComparePasswordAndHash.RUnlock()
	return calls
}

// HashPassword calls HashPasswordFunc.
func (mock *AuthServiceMock) HashPassword(password string) (string, error) {
	if mock.HashPasswordFunc == nil {
		panic("AuthServiceMock.HashPasswordFunc: method is nil but AuthService.HashPassword was just called")
	}
	callInfo := struct {
		Password string
	}{
		Password: password,
	}
	mock.lockHashPassword.Lock()
	mock.calls.HashPassword = append(mock.calls.HashPassword, callInfo)
	mock.lockHashPassword.Unlock()
	return mock.HashPasswordFunc(password)
}

// HashPasswordCalls gets all the calls that were made to HashPassword.
// Check the length with:
//
//	len(mockedAuthService.HashPasswordCalls())
func (mock *AuthServiceMock) HashPasswordCalls() []struct {
	Password string
} {
	var calls []struct {
		Password string
	}
	mock.lockHashPassword.RLock()
	calls = mock.calls.HashPassword
	mock.lockHashPassword.RUnlock()
	return calls
}
