// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package pkgmock

import (
	"mysite/pkgs/auth"
	"sync"
	"time"
)

// Ensure, that AuthServiceMock does implement auth.AuthService.
// If this is not the case, regenerate this file with moq.
var _ auth.AuthService = &AuthServiceMock{}

// AuthServiceMock is a mock implementation of auth.AuthService.
//
//	func TestSomethingThatUsesAuthService(t *testing.T) {
//
//		// make and configure a mocked auth.AuthService
//		mockedAuthService := &AuthServiceMock{
//			ComparePasswordAndHashFunc: func(password string, encodedHash string) (bool, error) {
//				panic("mock out the ComparePasswordAndHash method")
//			},
//			CreateTokenFunc: func(claims auth.Claims, signingKey []byte) (string, error) {
//				panic("mock out the CreateToken method")
//			},
//			HashPasswordFunc: func(password string) (string, error) {
//				panic("mock out the HashPassword method")
//			},
//			NewClaimsFunc: func(userId int, expiredTime time.Time) auth.Claims {
//				panic("mock out the NewClaims method")
//			},
//			ParseTokenFunc: func(tokenStr string, signingKey []byte) (*auth.Claims, error) {
//				panic("mock out the ParseToken method")
//			},
//		}
//
//		// use mockedAuthService in code that requires auth.AuthService
//		// and then make assertions.
//
//	}
type AuthServiceMock struct {
	// ComparePasswordAndHashFunc mocks the ComparePasswordAndHash method.
	ComparePasswordAndHashFunc func(password string, encodedHash string) (bool, error)

	// CreateTokenFunc mocks the CreateToken method.
	CreateTokenFunc func(claims auth.Claims, signingKey []byte) (string, error)

	// HashPasswordFunc mocks the HashPassword method.
	HashPasswordFunc func(password string) (string, error)

	// NewClaimsFunc mocks the NewClaims method.
	NewClaimsFunc func(userId int, expiredTime time.Time) auth.Claims

	// ParseTokenFunc mocks the ParseToken method.
	ParseTokenFunc func(tokenStr string, signingKey []byte) (*auth.Claims, error)

	// calls tracks calls to the methods.
	calls struct {
		// ComparePasswordAndHash holds details about calls to the ComparePasswordAndHash method.
		ComparePasswordAndHash []struct {
			// Password is the password argument value.
			Password string
			// EncodedHash is the encodedHash argument value.
			EncodedHash string
		}
		// CreateToken holds details about calls to the CreateToken method.
		CreateToken []struct {
			// Claims is the claims argument value.
			Claims auth.Claims
			// SigningKey is the signingKey argument value.
			SigningKey []byte
		}
		// HashPassword holds details about calls to the HashPassword method.
		HashPassword []struct {
			// Password is the password argument value.
			Password string
		}
		// NewClaims holds details about calls to the NewClaims method.
		NewClaims []struct {
			// UserId is the userId argument value.
			UserId int
			// ExpiredTime is the expiredTime argument value.
			ExpiredTime time.Time
		}
		// ParseToken holds details about calls to the ParseToken method.
		ParseToken []struct {
			// TokenStr is the tokenStr argument value.
			TokenStr string
			// SigningKey is the signingKey argument value.
			SigningKey []byte
		}
	}
	lockComparePasswordAndHash sync.RWMutex
	lockCreateToken            sync.RWMutex
	lockHashPassword           sync.RWMutex
	lockNewClaims              sync.RWMutex
	lockParseToken             sync.RWMutex
}

// ComparePasswordAndHash calls ComparePasswordAndHashFunc.
func (mock *AuthServiceMock) ComparePasswordAndHash(password string, encodedHash string) (bool, error) {
	if mock.ComparePasswordAndHashFunc == nil {
		panic("AuthServiceMock.ComparePasswordAndHashFunc: method is nil but AuthService.ComparePasswordAndHash was just called")
	}
	callInfo := struct {
		Password    string
		EncodedHash string
	}{
		Password:    password,
		EncodedHash: encodedHash,
	}
	mock.lockComparePasswordAndHash.Lock()
	mock.calls.ComparePasswordAndHash = append(mock.calls.ComparePasswordAndHash, callInfo)
	mock.lockComparePasswordAndHash.Unlock()
	return mock.ComparePasswordAndHashFunc(password, encodedHash)
}

// ComparePasswordAndHashCalls gets all the calls that were made to ComparePasswordAndHash.
// Check the length with:
//
//	len(mockedAuthService.ComparePasswordAndHashCalls())
func (mock *AuthServiceMock) ComparePasswordAndHashCalls() []struct {
	Password    string
	EncodedHash string
} {
	var calls []struct {
		Password    string
		EncodedHash string
	}
	mock.lockComparePasswordAndHash.RLock()
	calls = mock.calls.ComparePasswordAndHash
	mock.lockComparePasswordAndHash.RUnlock()
	return calls
}

// CreateToken calls CreateTokenFunc.
func (mock *AuthServiceMock) CreateToken(claims auth.Claims, signingKey []byte) (string, error) {
	if mock.CreateTokenFunc == nil {
		panic("AuthServiceMock.CreateTokenFunc: method is nil but AuthService.CreateToken was just called")
	}
	callInfo := struct {
		Claims     auth.Claims
		SigningKey []byte
	}{
		Claims:     claims,
		SigningKey: signingKey,
	}
	mock.lockCreateToken.Lock()
	mock.calls.CreateToken = append(mock.calls.CreateToken, callInfo)
	mock.lockCreateToken.Unlock()
	return mock.CreateTokenFunc(claims, signingKey)
}

// CreateTokenCalls gets all the calls that were made to CreateToken.
// Check the length with:
//
//	len(mockedAuthService.CreateTokenCalls())
func (mock *AuthServiceMock) CreateTokenCalls() []struct {
	Claims     auth.Claims
	SigningKey []byte
} {
	var calls []struct {
		Claims     auth.Claims
		SigningKey []byte
	}
	mock.lockCreateToken.RLock()
	calls = mock.calls.CreateToken
	mock.lockCreateToken.RUnlock()
	return calls
}

// HashPassword calls HashPasswordFunc.
func (mock *AuthServiceMock) HashPassword(password string) (string, error) {
	if mock.HashPasswordFunc == nil {
		panic("AuthServiceMock.HashPasswordFunc: method is nil but AuthService.HashPassword was just called")
	}
	callInfo := struct {
		Password string
	}{
		Password: password,
	}
	mock.lockHashPassword.Lock()
	mock.calls.HashPassword = append(mock.calls.HashPassword, callInfo)
	mock.lockHashPassword.Unlock()
	return mock.HashPasswordFunc(password)
}

// HashPasswordCalls gets all the calls that were made to HashPassword.
// Check the length with:
//
//	len(mockedAuthService.HashPasswordCalls())
func (mock *AuthServiceMock) HashPasswordCalls() []struct {
	Password string
} {
	var calls []struct {
		Password string
	}
	mock.lockHashPassword.RLock()
	calls = mock.calls.HashPassword
	mock.lockHashPassword.RUnlock()
	return calls
}

// NewClaims calls NewClaimsFunc.
func (mock *AuthServiceMock) NewClaims(userId int, expiredTime time.Time) auth.Claims {
	if mock.NewClaimsFunc == nil {
		panic("AuthServiceMock.NewClaimsFunc: method is nil but AuthService.NewClaims was just called")
	}
	callInfo := struct {
		UserId      int
		ExpiredTime time.Time
	}{
		UserId:      userId,
		ExpiredTime: expiredTime,
	}
	mock.lockNewClaims.Lock()
	mock.calls.NewClaims = append(mock.calls.NewClaims, callInfo)
	mock.lockNewClaims.Unlock()
	return mock.NewClaimsFunc(userId, expiredTime)
}

// NewClaimsCalls gets all the calls that were made to NewClaims.
// Check the length with:
//
//	len(mockedAuthService.NewClaimsCalls())
func (mock *AuthServiceMock) NewClaimsCalls() []struct {
	UserId      int
	ExpiredTime time.Time
} {
	var calls []struct {
		UserId      int
		ExpiredTime time.Time
	}
	mock.lockNewClaims.RLock()
	calls = mock.calls.NewClaims
	mock.lockNewClaims.RUnlock()
	return calls
}

// ParseToken calls ParseTokenFunc.
func (mock *AuthServiceMock) ParseToken(tokenStr string, signingKey []byte) (*auth.Claims, error) {
	if mock.ParseTokenFunc == nil {
		panic("AuthServiceMock.ParseTokenFunc: method is nil but AuthService.ParseToken was just called")
	}
	callInfo := struct {
		TokenStr   string
		SigningKey []byte
	}{
		TokenStr:   tokenStr,
		SigningKey: signingKey,
	}
	mock.lockParseToken.Lock()
	mock.calls.ParseToken = append(mock.calls.ParseToken, callInfo)
	mock.lockParseToken.Unlock()
	return mock.ParseTokenFunc(tokenStr, signingKey)
}

// ParseTokenCalls gets all the calls that were made to ParseToken.
// Check the length with:
//
//	len(mockedAuthService.ParseTokenCalls())
func (mock *AuthServiceMock) ParseTokenCalls() []struct {
	TokenStr   string
	SigningKey []byte
} {
	var calls []struct {
		TokenStr   string
		SigningKey []byte
	}
	mock.lockParseToken.RLock()
	calls = mock.calls.ParseToken
	mock.lockParseToken.RUnlock()
	return calls
}
