// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package repomock

import (
	"context"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"mysite/models/pgmodel"
	"mysite/repositories/useraccountrepo"
	"sync"
)

// Ensure, that UserAccountRepoMock does implement useraccountrepo.UserAccountRepo.
// If this is not the case, regenerate this file with moq.
var _ useraccountrepo.UserAccountRepo = &UserAccountRepoMock{}

// UserAccountRepoMock is a mock implementation of useraccountrepo.UserAccountRepo.
//
//	func TestSomethingThatUsesUserAccountRepo(t *testing.T) {
//
//		// make and configure a mocked useraccountrepo.UserAccountRepo
//		mockedUserAccountRepo := &UserAccountRepoMock{
//			ActiveUserFunc: func(ctx context.Context, tx boil.ContextTransactor, pgUser pgmodel.UserAccount) error {
//				panic("mock out the ActiveUser method")
//			},
//			GetActiveUserAccountByIdFunc: func(ctx context.Context, tx boil.ContextTransactor, userId int) (*pgmodel.UserAccount, error) {
//				panic("mock out the GetActiveUserAccountById method")
//			},
//			GetActiveUserAccountByNameFunc: func(ctx context.Context, tx boil.ContextTransactor, userName string) (*pgmodel.UserAccount, error) {
//				panic("mock out the GetActiveUserAccountByName method")
//			},
//			GetUserAccountByUserNameFunc: func(ctx context.Context, tx boil.ContextTransactor, userName string) (*pgmodel.UserAccount, error) {
//				panic("mock out the GetUserAccountByUserName method")
//			},
//			InsertFunc: func(ctx context.Context, tx boil.ContextTransactor, user *pgmodel.UserAccount) error {
//				panic("mock out the Insert method")
//			},
//		}
//
//		// use mockedUserAccountRepo in code that requires useraccountrepo.UserAccountRepo
//		// and then make assertions.
//
//	}
type UserAccountRepoMock struct {
	// ActiveUserFunc mocks the ActiveUser method.
	ActiveUserFunc func(ctx context.Context, tx boil.ContextTransactor, pgUser pgmodel.UserAccount) error

	// GetActiveUserAccountByIdFunc mocks the GetActiveUserAccountById method.
	GetActiveUserAccountByIdFunc func(ctx context.Context, tx boil.ContextTransactor, userId int) (*pgmodel.UserAccount, error)

	// GetActiveUserAccountByNameFunc mocks the GetActiveUserAccountByName method.
	GetActiveUserAccountByNameFunc func(ctx context.Context, tx boil.ContextTransactor, userName string) (*pgmodel.UserAccount, error)

	// GetUserAccountByUserNameFunc mocks the GetUserAccountByUserName method.
	GetUserAccountByUserNameFunc func(ctx context.Context, tx boil.ContextTransactor, userName string) (*pgmodel.UserAccount, error)

	// InsertFunc mocks the Insert method.
	InsertFunc func(ctx context.Context, tx boil.ContextTransactor, user *pgmodel.UserAccount) error

	// calls tracks calls to the methods.
	calls struct {
		// ActiveUser holds details about calls to the ActiveUser method.
		ActiveUser []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx boil.ContextTransactor
			// PgUser is the pgUser argument value.
			PgUser pgmodel.UserAccount
		}
		// GetActiveUserAccountById holds details about calls to the GetActiveUserAccountById method.
		GetActiveUserAccountById []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx boil.ContextTransactor
			// UserId is the userId argument value.
			UserId int
		}
		// GetActiveUserAccountByName holds details about calls to the GetActiveUserAccountByName method.
		GetActiveUserAccountByName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx boil.ContextTransactor
			// UserName is the userName argument value.
			UserName string
		}
		// GetUserAccountByUserName holds details about calls to the GetUserAccountByUserName method.
		GetUserAccountByUserName []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx boil.ContextTransactor
			// UserName is the userName argument value.
			UserName string
		}
		// Insert holds details about calls to the Insert method.
		Insert []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Tx is the tx argument value.
			Tx boil.ContextTransactor
			// User is the user argument value.
			User *pgmodel.UserAccount
		}
	}
	lockActiveUser                 sync.RWMutex
	lockGetActiveUserAccountById   sync.RWMutex
	lockGetActiveUserAccountByName sync.RWMutex
	lockGetUserAccountByUserName   sync.RWMutex
	lockInsert                     sync.RWMutex
}

// ActiveUser calls ActiveUserFunc.
func (mock *UserAccountRepoMock) ActiveUser(ctx context.Context, tx boil.ContextTransactor, pgUser pgmodel.UserAccount) error {
	if mock.ActiveUserFunc == nil {
		panic("UserAccountRepoMock.ActiveUserFunc: method is nil but UserAccountRepo.ActiveUser was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Tx     boil.ContextTransactor
		PgUser pgmodel.UserAccount
	}{
		Ctx:    ctx,
		Tx:     tx,
		PgUser: pgUser,
	}
	mock.lockActiveUser.Lock()
	mock.calls.ActiveUser = append(mock.calls.ActiveUser, callInfo)
	mock.lockActiveUser.Unlock()
	return mock.ActiveUserFunc(ctx, tx, pgUser)
}

// ActiveUserCalls gets all the calls that were made to ActiveUser.
// Check the length with:
//
//	len(mockedUserAccountRepo.ActiveUserCalls())
func (mock *UserAccountRepoMock) ActiveUserCalls() []struct {
	Ctx    context.Context
	Tx     boil.ContextTransactor
	PgUser pgmodel.UserAccount
} {
	var calls []struct {
		Ctx    context.Context
		Tx     boil.ContextTransactor
		PgUser pgmodel.UserAccount
	}
	mock.lockActiveUser.RLock()
	calls = mock.calls.ActiveUser
	mock.lockActiveUser.RUnlock()
	return calls
}

// GetActiveUserAccountById calls GetActiveUserAccountByIdFunc.
func (mock *UserAccountRepoMock) GetActiveUserAccountById(ctx context.Context, tx boil.ContextTransactor, userId int) (*pgmodel.UserAccount, error) {
	if mock.GetActiveUserAccountByIdFunc == nil {
		panic("UserAccountRepoMock.GetActiveUserAccountByIdFunc: method is nil but UserAccountRepo.GetActiveUserAccountById was just called")
	}
	callInfo := struct {
		Ctx    context.Context
		Tx     boil.ContextTransactor
		UserId int
	}{
		Ctx:    ctx,
		Tx:     tx,
		UserId: userId,
	}
	mock.lockGetActiveUserAccountById.Lock()
	mock.calls.GetActiveUserAccountById = append(mock.calls.GetActiveUserAccountById, callInfo)
	mock.lockGetActiveUserAccountById.Unlock()
	return mock.GetActiveUserAccountByIdFunc(ctx, tx, userId)
}

// GetActiveUserAccountByIdCalls gets all the calls that were made to GetActiveUserAccountById.
// Check the length with:
//
//	len(mockedUserAccountRepo.GetActiveUserAccountByIdCalls())
func (mock *UserAccountRepoMock) GetActiveUserAccountByIdCalls() []struct {
	Ctx    context.Context
	Tx     boil.ContextTransactor
	UserId int
} {
	var calls []struct {
		Ctx    context.Context
		Tx     boil.ContextTransactor
		UserId int
	}
	mock.lockGetActiveUserAccountById.RLock()
	calls = mock.calls.GetActiveUserAccountById
	mock.lockGetActiveUserAccountById.RUnlock()
	return calls
}

// GetActiveUserAccountByName calls GetActiveUserAccountByNameFunc.
func (mock *UserAccountRepoMock) GetActiveUserAccountByName(ctx context.Context, tx boil.ContextTransactor, userName string) (*pgmodel.UserAccount, error) {
	if mock.GetActiveUserAccountByNameFunc == nil {
		panic("UserAccountRepoMock.GetActiveUserAccountByNameFunc: method is nil but UserAccountRepo.GetActiveUserAccountByName was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Tx       boil.ContextTransactor
		UserName string
	}{
		Ctx:      ctx,
		Tx:       tx,
		UserName: userName,
	}
	mock.lockGetActiveUserAccountByName.Lock()
	mock.calls.GetActiveUserAccountByName = append(mock.calls.GetActiveUserAccountByName, callInfo)
	mock.lockGetActiveUserAccountByName.Unlock()
	return mock.GetActiveUserAccountByNameFunc(ctx, tx, userName)
}

// GetActiveUserAccountByNameCalls gets all the calls that were made to GetActiveUserAccountByName.
// Check the length with:
//
//	len(mockedUserAccountRepo.GetActiveUserAccountByNameCalls())
func (mock *UserAccountRepoMock) GetActiveUserAccountByNameCalls() []struct {
	Ctx      context.Context
	Tx       boil.ContextTransactor
	UserName string
} {
	var calls []struct {
		Ctx      context.Context
		Tx       boil.ContextTransactor
		UserName string
	}
	mock.lockGetActiveUserAccountByName.RLock()
	calls = mock.calls.GetActiveUserAccountByName
	mock.lockGetActiveUserAccountByName.RUnlock()
	return calls
}

// GetUserAccountByUserName calls GetUserAccountByUserNameFunc.
func (mock *UserAccountRepoMock) GetUserAccountByUserName(ctx context.Context, tx boil.ContextTransactor, userName string) (*pgmodel.UserAccount, error) {
	if mock.GetUserAccountByUserNameFunc == nil {
		panic("UserAccountRepoMock.GetUserAccountByUserNameFunc: method is nil but UserAccountRepo.GetUserAccountByUserName was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		Tx       boil.ContextTransactor
		UserName string
	}{
		Ctx:      ctx,
		Tx:       tx,
		UserName: userName,
	}
	mock.lockGetUserAccountByUserName.Lock()
	mock.calls.GetUserAccountByUserName = append(mock.calls.GetUserAccountByUserName, callInfo)
	mock.lockGetUserAccountByUserName.Unlock()
	return mock.GetUserAccountByUserNameFunc(ctx, tx, userName)
}

// GetUserAccountByUserNameCalls gets all the calls that were made to GetUserAccountByUserName.
// Check the length with:
//
//	len(mockedUserAccountRepo.GetUserAccountByUserNameCalls())
func (mock *UserAccountRepoMock) GetUserAccountByUserNameCalls() []struct {
	Ctx      context.Context
	Tx       boil.ContextTransactor
	UserName string
} {
	var calls []struct {
		Ctx      context.Context
		Tx       boil.ContextTransactor
		UserName string
	}
	mock.lockGetUserAccountByUserName.RLock()
	calls = mock.calls.GetUserAccountByUserName
	mock.lockGetUserAccountByUserName.RUnlock()
	return calls
}

// Insert calls InsertFunc.
func (mock *UserAccountRepoMock) Insert(ctx context.Context, tx boil.ContextTransactor, user *pgmodel.UserAccount) error {
	if mock.InsertFunc == nil {
		panic("UserAccountRepoMock.InsertFunc: method is nil but UserAccountRepo.Insert was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Tx   boil.ContextTransactor
		User *pgmodel.UserAccount
	}{
		Ctx:  ctx,
		Tx:   tx,
		User: user,
	}
	mock.lockInsert.Lock()
	mock.calls.Insert = append(mock.calls.Insert, callInfo)
	mock.lockInsert.Unlock()
	return mock.InsertFunc(ctx, tx, user)
}

// InsertCalls gets all the calls that were made to Insert.
// Check the length with:
//
//	len(mockedUserAccountRepo.InsertCalls())
func (mock *UserAccountRepoMock) InsertCalls() []struct {
	Ctx  context.Context
	Tx   boil.ContextTransactor
	User *pgmodel.UserAccount
} {
	var calls []struct {
		Ctx  context.Context
		Tx   boil.ContextTransactor
		User *pgmodel.UserAccount
	}
	mock.lockInsert.RLock()
	calls = mock.calls.Insert
	mock.lockInsert.RUnlock()
	return calls
}
